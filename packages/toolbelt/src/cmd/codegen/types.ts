/**
 * Copyright (c) The Blossom GraphQL Team.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import fs from 'fs';
import path from 'path';

import VERSION from '../../version';
import { parseFileGraph } from '../../lib/parsing';
import {
  generateTypesFileNodes,
  codegenPipelineMaker,
} from '../../lib/codegen';
import { appPath, typesFilePath } from '../../lib/paths';
import { linkTypesFile } from '../../lib/linking';
import { cliRunWrapper } from '../../lib/runtime';

const HEADER_TEXT = `/**
* Autogenerated with Blossom Toolbelt v${VERSION}.
*
* DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
*/`;

const generateTypesFile = codegenPipelineMaker((filePath, fileGraph) => {
  const linkedTypesFile = linkTypesFile(filePath, fileGraph);

  return generateTypesFileNodes(linkedTypesFile);
}, HEADER_TEXT);

export async function generateTypes(options: {
  file?: string;
  outputFile?: string | boolean;
  recursive?: boolean;
  stdin?: boolean;
  stdout?: boolean;
}) {
  let fullInputFilePath: string = path.join(process.cwd(), 'schema.gql');

  if (options.stdin) {
    throw new Error('Implement me.');
  } else if (options.file) {
    fullInputFilePath = appPath(options.file);
  } else {
    throw new Error('An input for the SDL must be specified.');
  }

  const filesOutput: { [key: string]: string } = {};
  const parsedFileGraph = await parseFileGraph(fullInputFilePath);

  filesOutput[fullInputFilePath] = await generateTypesFile(
    fullInputFilePath,
    parsedFileGraph,
  );

  // On recursive mode, output must be generated for all files.
  if (options.recursive) {
    await Promise.all(
      [...parsedFileGraph.keys()].map(async fullPath => {
        filesOutput[fullPath] = await generateTypesFile(
          fullPath,
          parsedFileGraph,
        );
      }),
    );
  }

  if (options.stdout && !options.recursive) {
    console.log(filesOutput[fullInputFilePath]);
  } else {
    await Promise.all(
      Object.entries(filesOutput).map(async ([fullPath, contents]) => {
        const typesFilePathname = typesFilePath(fullPath);

        await fs.promises.writeFile(typesFilePathname, contents);
      }),
    );
  }
}

export default cliRunWrapper(generateTypes);
